// ---------------------------------------------------------------------------
// -- Drago -- Export to RTF module ---------------------- UExporterRTF.pas --
// ---------------------------------------------------------------------------

unit UExporterRTF;

// ---------------------------------------------------------------------------

interface

uses
  Types, Classes, Graphics, SysUtils, StrUtils,
  UExporter, CodePages;

type
  TExporterRTF = class(TExporter)
  private
    FileName : string;
    f : Text;
    Stream : string;
    procedure DoHeaderOrFooter(sLeft, sCenter, sRight : string);
    function  ColImage(i : integer) : string;
    function  ColString(i : integer; text : array of string) : string;
    procedure Write(s : string);
    procedure Writeln(s : string);
  public
    constructor Create(aFileName : string); override;
    destructor Destroy; override;
    procedure BeginDoc(var ok : boolean); override;
    procedure EndDoc; override;
    procedure BeginGroup; override;
    procedure EndGroup; override;
    procedure AddPage; override;
    procedure SetupHeader(sLeft, sCenter, sRight : string; addLine : boolean); override;
    procedure SetupFooter(sLeft, sCenter, sRight : string; addLine : boolean); override;
    function  PrinterPxPerInchX : integer; override;
    function  PrinterPxPerInchY : integer; override;
    procedure SetPageMargins(mmLeft, mmTop, mmRight, mmBottom : integer); override;
    procedure FontName(name : string); override;
    procedure FontSize(ptSize : integer); override;
    procedure FontStyle(styles : TExporterFontStyles); override;
    procedure TextAlign(align : TExporterTextAlign) ; override;
    procedure NewLine; override;
    procedure WriteText(s : string); override;
    procedure DrawLine(double: boolean); override;
    procedure ClearColumns; override;
    procedure AddColumn(mmLeft, mmRight : integer; colAlign : TExporterColAlign); override;
    procedure WriteTextAcrossCols(text : TStringDynArray; cp : TCodePage = cpDefault); override;
    procedure DrawImagesAcrossCols(n : integer); override;
  end;

// ---------------------------------------------------------------------------

implementation

uses
  DefineUi, UStatus, UnicodeUtils, UImageExporterWMF;

// -- Handling of RTF strings

function RTF_UniDecString(const s : UTF8String) : string;
var
  w : WideString;
  i : integer;
begin
  w := UTF8Decode(s);

  if IsAnsiString(w)
    then Result := s
    else
      begin
        Result := '{\uc0 ';

        for i := 1 to Length(w) do
          if w[i] < WideChar(128)
            then Result := Result + w[i]
            else
              if w[i] < WideChar(256)
                then Result := Result + '\''' + LowerCase(IntToHex(ord(w[i]), 2))
                else
                  if w[i] < WideChar(32768)
                    then Result := Result + '\u' + IntToStr(integer(w[i])) + ' '
                    else Result := Result + '\u' + IntToStr(integer(w[i]) - 65536) + ' ';

        Result := Result + '}'
      end
end;

// -- Handling of special characters: '\', '{', '}' and chr(127) .. chr(255)

function RTF_Special(const s : string) : string;
begin
  Result := AnsiReplaceStr(s,      '\', '\\');
  Result := AnsiReplaceStr(Result, '{', '\{');
  Result := AnsiReplaceStr(Result, '}', '\}');
  Result := RTF_UniDecString(Result)
end;

function RTF_LineBreak(const s : string) : string;
var
  k : integer;
begin
  k := Pos(#13#10, s);
  if k = 0
    then Result := RTF_Special(s)
    else Result := RTF_Special(Copy(s, 1, k - 1))
              + '\par '
              + RTF_LineBreak(Copy(s, k + 2, Length(s)))
end;

// -- Construction et destruction --------------------------------------------

constructor TExporterRTF.Create(aFileName : string);
begin
  FExportMode   := emExportRTF;
  fExportFigure := eiWMF;
  FileName      := aFileName;
  PaperSize     := PaperNameToSize(Settings.prPaperSize, False);
  Stream        := ''
end;

destructor TExporterRTF.Destroy;
begin
  Stream := '';
  inherited Destroy
end;

// -- Structure of the document ----------------------------------------------

// -- Document

procedure TExporterRTF.BeginDoc(var ok : boolean);
var
  x : integer;
begin
  ok := True;
  assign(f, FileName);
  {$i-}
  rewrite(f);
  {$i+}
  if IOResult <> 0 then
    begin
      ok := False;
      exit
    end;
    
  Writeln(Format('{\rtf1\ansi\deff0 {\fonttbl {\f0 %s;}}\viewkind4',
                 [fFontName]));
  Writeln('{\info {\comment Generated by ' + AppName + ' ' + AppVersion + '}}');

  // specify paper size
  Writeln(Format('\paperw%d\paperh%d', [Round(PaperSize.cx * TwipsPerMm),
                                        Round(PaperSize.cy * TwipsPerMm)]));

  // specify orientation
  if Settings.prLandscape
    then Writeln('\landscape');

  // swap dimensions when landscape
  if Settings.prLandscape then
    begin
      x := PaperSize.cx; PaperSize.cx := PaperSize.cy; PaperSize.cy := x
    end;

  Writeln(Format('\f0\fs%d', [fFontSize * 2]));
  //SetPageMargins(10, 10, 10, 10); 2 times in file if set as default
  ClearColumns
end;

procedure TExporterRTF.EndDoc;
begin
  Writeln('}');
  system.write(f, Stream);
  close(f)
end;

// -- Groups

function PosLast(sub, str : string; offset : integer = 1) : integer;
var
  i, j : integer;
begin
  i := PosEx(sub, str, offset);
  if i = 0
    then Result := 0
    else
      begin
        j := PosEx(sub, str, i + 1);
        if j = 0
          then Result := i
          else Result := PosLast(sub, str, i + 1)
      end
end;

procedure TExporterRTF.BeginGroup;
begin
  system.write(f, Stream);
  Stream := ''
end;

procedure TExporterRTF.EndGroup;
var
  i : integer;
  s1, s2 : string;
begin
  i := PosLast('\pard', Stream);
  if i = 0
    then exit;
  s1 := Copy(Stream, 1, i - 1);
  s2 := Copy(Stream, i, Length(Stream));

  s1 := StringReplace(s1, '\pard', '\pard\keep\keepn', [rfReplaceAll]);
  s2 := StringReplace(s2, '\pard', '\pard\keep', []);

  Stream := s1 + s2
end;

procedure TExporterRTF.AddPage;
begin
  Writeln('\page')
end;

// -- Header and Footer

procedure TExporterRTF.DoHeaderOrFooter(sLeft, sCenter, sRight : string);
var
  xRight, xMiddle : integer;    
begin
  sRight  := AnsiReplaceStr(RTF_Special(sRight ), '<<pagenumber>>', '\chpgn');
  sLeft   := AnsiReplaceStr(RTF_Special(sLeft  ), '<<pagenumber>>', '\chpgn');
  sCenter := AnsiReplaceStr(RTF_Special(sCenter), '<<pagenumber>>', '\chpgn');

  xRight  := PaperSize.cx - PageMargins.Left - PageMargins.Right;
  xMiddle := xRight div 2;
  Writeln(Format('\fs%d \tqc\tx%d\tqr\tx%d',
                 [fFontSize * 2,
                  round(xMiddle * TwipsPerMm),
                  round(xRight  * TwipsPerMm)]));

  Write(Format('%s\tab %s\tab %s', [RTF_UniDecString(sLeft),
                                    RTF_UniDecString(sCenter),
                                    RTF_UniDecString(sRight)]))
end;

procedure TExporterRTF.SetupHeader(sLeft, sCenter, sRight : string; addLine : boolean);
begin
  Write('{\header');
  DoHeaderOrFooter(sLeft, sCenter, sRight);
  //Write('\par');
  if addLine
    then Writeln('\brdrb\brdrs');
  Writeln('\par\pard\par}')
end;

procedure TExporterRTF.SetupFooter(sLeft, sCenter, sRight : string; addLine : boolean);
begin
  Write('{\footer\par');
  if addLine
    then Writeln('\brdrt\brdrs');
  DoHeaderOrFooter(sLeft, sCenter, sRight);
  Writeln('\par}')
end;

// -- Conversions

function TExporterRTF.PrinterPxPerInchX : integer;
begin
  Result := 360
end;

function TExporterRTF.PrinterPxPerInchY : integer;
begin
  Result := 360
end;

procedure TExporterRTF.SetPageMargins(mmLeft, mmTop, mmRight, mmBottom : integer);
begin
  PageMargins := Rect(mmLeft, mmTop, mmRight, mmBottom);
  Writeln(Format('\margl%d\margt%d\margr%d\margb%d\footery%d',
                 [round(mmLeft   * TwipsPerMm),
                  round(mmTop    * TwipsPerMm),
                  round(mmRight  * TwipsPerMm),
                  round(mmBottom * TwipsPerMm),
                  round(mmBottom * TwipsPerMm)]))
end;

// -- Fonts

procedure TExporterRTF.FontName(name : string);
begin
  fFontName := name
end;

procedure TExporterRTF.FontSize(ptSize : integer);
begin
  fFontSize := ptSize
end;

procedure TExporterRTF.FontStyle(styles : TExporterFontStyles);
begin
  Write('\b0\i0\ul0');
  if efsBold      in styles then Write('\b');
  if efsItalic    in styles then Write('\i');
  if efsUnderline in styles then Write('\ul');
  Writeln('')
end;

// -- Text

procedure TExporterRTF.NewLine;
begin
  Writeln('\par')
end;

procedure TExporterRTF.TextAlign(align : TExporterTextAlign);
// TExporterTextAlign = (etaLeft, etaRight, etaCenter, etaJustified);
const alignTag : string = 'lrcj';
begin
  Write('\q' + 'lrcj'[ord(align) + 1])
end;

procedure TExporterRTF.WriteText(s : string);
begin
  s := RTF_Special(s);
  s := StringReplace(s, ^M^J, '\par ', [rfReplaceAll]);
  Writeln(s + '\par')
end;

procedure TExporterRTF.DrawLine(double: boolean);
begin
  if not double
    then Writeln('{\pard\brdrt\brdrs\par}')
    else Writeln('{\pard\brdrt\brdrth\par}')
end;

// -- Columns

procedure TExporterRTF.ClearColumns;
begin
  fColNum := 0
end;

procedure TExporterRTF.AddColumn(mmLeft, mmRight : integer; colAlign : TExporterColAlign);
begin
  fColLeft [fColNum] := round(mmLeft  * TwipsPerMm);
  fColRight[fColNum] := round(mmRight * TwipsPerMm);
  fColAlign[fColNum] := colAlign;
  inc(fColNum)
end;

function AlignTag(colAlign : TExporterColAlign) : string;
begin
  case colAlign of
    ecaLeft   : Result := Result + '\ql ';
    ecaRight  : Result := Result + '\qr ';
    ecaCenter : Result := Result + '\qc '
  end
end;

function TExporterRTF.ColString(i : integer; text : array of string) : string;
begin
  if i > High(text)
    then Result := '\pard\intbl\cell'
    else Result := '\pard\intbl ' + AlignTag(fColAlign[i])
                        + RTF_LineBreak(text[i])
                        + '\cell'
end;

procedure TExporterRTF.WriteTextAcrossCols(text : TStringDynArray; cp : TCodePage = cpDefault);
var
  i : integer;
begin
  if fColNum = 0
    then exit;
  CleanDelimiters(text);

  if fColNum = 1 then
    begin
      Writeln('{\pard' + AlignTag(fColAlign[0])
                       + RTF_LineBreak(text[0])
                       + '\par}');
      exit
    end;

  Writeln('{');
  Write('{\trowd\trgaph0');
  Write(Format('\trleft%d\cellx%d', [fColLeft[0], fColRight[0]]));
  for i := 1 to fColNum - 1 do
    Write(Format('\cellx%d\cellx%d', [fColLeft[i], fColRight[i]]));
  Writeln('');
  Writeln(ColString(0, text));
  for i := 1 to fColNum - 1 do
    Writeln('\pard\intbl\cell' + ColString(i, text));
  Writeln('\row}');
  Writeln('}')
end;

// -- Images

function MetafileToRTF(Metafile : TMetafile; PxPerInchX : integer) : string;
var
  metastream : TStringStream;
  s, hexa : string;
  pxSize, mmSize, i : integer;
begin
  pxSize := Metafile.Width;
  mmSize := round(pxSize * 25.4 / PxPerInchX);
  Metafile.MMWidth  := mmSize * 100;
  Metafile.MMHeight := mmSize * 100;
  metastream := TStringStream.Create('');
  Metafile.SaveToStream(metastream);
  with metastream do
    begin
      Seek(22, soFromBeginning); // skip placeable meta header
      s := ReadString(Size);
      Destroy
    end;

  hexa := #13#10;
  for i := 1 to Length(s) do
    begin
      hexa := hexa + IntToHex(ord(s[i]), 2);
      if i mod 64 = 0
        then hexa := hexa + #13#10
    end;

  Result := Format('{\pict\wmetafile8\picw%d\pich%d' +
                    '\picwgoal%d\pichgoal%d%s}',
                    [round(mmSize * 100),
                     round(mmSize * 100),
                     round(TwipsPerMm * mmSize),
                     round(TwipsPerMm * mmSize), hexa])
end;

function TExporterRTF.ColImage(i : integer) : string;
var
  metafile : TMetafile;
begin
  metafile := (FExportImg[i] as TExportedImageWMF).FMetafile;
  if i > High(FExportImg)
    then Result := '\pard\intbl\cell'
    else Result := '\pard\intbl ' + AlignTag(fColAlign[i])
                        + MetafileToRTF(metafile, PrinterPxPerInchX)
                        + '\cell'
end;

procedure TExporterRTF.DrawImagesAcrossCols(n : integer);
var
  i : integer;
  metafile : TMetafile;
begin
  if n = 0
    then exit;

  if n = 1 then
    begin
      metafile := (FExportImg[0] as TExportedImageWMF).FMetafile;
      Writeln('{\pard' + AlignTag(fColAlign[0])
                       + MetafileToRTF(metafile, PrinterPxPerInchX)
                       + '\par}');
      exit
    end;

  Writeln('{');
  Write('{\trowd\trgaph0');
  Write(Format('\trleft%d\cellx%d', [fColLeft[0], fColRight[0]]));
  for i := 1 to n - 1 do
    Write(Format('\cellx%d\cellx%d', [fColLeft[i], fColRight[i]]));
  Writeln('');
  Writeln(ColImage(0));
  for i := 1 to n - 1 do
    Writeln('\pard\intbl\cell' + ColImage(i));
  Writeln('\row}');
  Writeln('}')
end;

// -- Helpers

procedure TExporterRTF.Writeln(s : string);
begin
  Write (s + #13#10)
end;

procedure TExporterRTF.Write (s : string);
begin
  Stream := Stream + s
end;

// ---------------------------------------------------------------------------

end.
